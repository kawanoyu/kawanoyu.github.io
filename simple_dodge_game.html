<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dolphin Dodger (Vector) — シンプル避けゲーム</title>
  <style>
    :root { --bg:#0f1220; --fg:#e9ecf1; --acc:#6cf; --muted:#aab1c6; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0f1d,#131937);color:var(--fg);font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", Helvetica, Arial, sans-serif;}
    .wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;gap:16px;padding:16px}
    canvas{background: radial-gradient(1200px 600px at 50% 0%, rgba(108,204,255,0.12), transparent 60%), #0b0f1d; border:1px solid rgba(255,255,255,0.08); border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,0.35);} 
    .hud{display:flex;gap:16px;align-items:center;justify-content:space-between;width:min(720px,95vw)}
    .score{font-weight:700}
    .btn{appearance:none;border:0;border-radius:999px;padding:10px 16px;background:rgba(255,255,255,0.08);color:var(--fg);cursor:pointer;font-weight:700;backdrop-filter: blur(4px);} 
    .btn:hover{background:rgba(255,255,255,0.12)}
    .muted{color:var(--muted)}
    .mobile-ctrls{display:none;gap:8px}
    .ctrl{flex:1;min-width:100px;padding:14px 0;border-radius:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.08);font-weight:700}
    @media (max-width: 700px){ .mobile-ctrls{display:flex} }
    .toast{position:fixed;bottom:12px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);padding:8px 12px;border-radius:12px;color:var(--muted);font-size:14px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="muted">矢印キー / A・D / タップで移動</div>
      <button id="restart" class="btn" aria-label="Restart">リスタート</button>
    </div>
    <canvas id="game" width="720" height="480" aria-label="Dolphin Dodger game"></canvas>
    <div class="mobile-ctrls" aria-hidden="false">
      <button class="ctrl" id="leftBtn">◀︎ 左</button>
      <button class="ctrl" id="rightBtn">右 ▶︎</button>
    </div>
  </div>
  <div class="toast" id="toast">スペースで開始 / Pで一時停止</div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const restartBtn = document.getElementById('restart');
    const toast = document.getElementById('toast');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');

    function fitCanvas(){
      const maxW = Math.min(720, window.innerWidth*0.95);
      const scale = maxW / canvas.width;
      canvas.style.width = `${canvas.width*scale}px`;
      canvas.style.height = `${canvas.height*scale}px`;
    }
    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    const state = {
      running: false,
      paused: false,
      last: 0,
      t: 0,
      score: 0,
      speed: 130,
      player: { x: canvas.width/2, y: canvas.height-60, w: 60, h: 26, vx: 0 },
      obstacles: [],
      inputs: { left:false, right:false },
      _spawnTimer: 0
    };

    function reset(){
      state.running = false; state.paused = false;
      state.t = 0; state.last = 0; state.score = 0; scoreEl.textContent = '0';
      state.speed = 130;
      state.player = { x: canvas.width/2, y: canvas.height-60, w: 60, h: 26, vx: 0 };
      state.obstacles = []; state._spawnTimer = 0;
      toast.textContent = 'スペースで開始 / Pで一時停止';
      draw();
    }

    function start(){ if(state.running) return; state.running = true; state.paused = false; requestAnimationFrame(loop); }
    function pauseToggle(){ if(!state.running) return; state.paused = !state.paused; if(!state.paused) requestAnimationFrame(loop); }

    function spawnObstacle(){
      const w = 40 + Math.random()*80;
      const x = Math.random()*(canvas.width - w);
      const speed = state.speed * (0.9 + Math.random()*0.2);
      state.obstacles.push({ x, y: -32, w, h: 24, vy: speed, phase: Math.random()*Math.PI*2 });
    }

    function handleInput(dt){
      const accel = 900, maxV = 420;
      if(state.inputs.left && !state.inputs.right) state.player.vx -= accel*dt;
      else if(state.inputs.right && !state.inputs.left) state.player.vx += accel*dt;
      else state.player.vx *= 0.85;
      state.player.vx = Math.max(-maxV, Math.min(maxV, state.player.vx));
      state.player.x += state.player.vx * dt;
      if(state.player.x < 0){ state.player.x = 0; state.player.vx *= -0.3; }
      if(state.player.x + state.player.w > canvas.width){ state.player.x = canvas.width - state.player.w; state.player.vx *= -0.3; }
    }

    function collide(a,b){ return !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y); }

    function update(dt){
      state.t += dt; state.score += dt*10; scoreEl.textContent = Math.floor(state.score);
      state.speed += dt*6;
      const spawnRate = 0.8 - Math.min(0.6, state.t*0.015);
      state._spawnTimer -= dt;
      if(state._spawnTimer <= 0){ spawnObstacle(); state._spawnTimer = spawnRate; }
      handleInput(dt);
      for(const o of state.obstacles){
        o.y += o.vy*dt;
        // 横ゆらぎ
        o.phase += dt*2;
        o.x += Math.sin(o.phase) * 20 * dt;
      }
      state.obstacles = state.obstacles.filter(o => o.y < canvas.height + 40);
      for(const o of state.obstacles){ if(collide({x:state.player.x,y:state.player.y,w:state.player.w,h:state.player.h}, o)){ gameOver(); break; } }
    }

    // ---- Vector Drawing ----
    function drawDolphin(x, y, vx){
      ctx.save();
      ctx.translate(x + 30, y + 10); // center-ish
      ctx.rotate(Math.max(-0.35, Math.min(0.35, vx*0.002)));
      // body
      const grd = ctx.createLinearGradient(-30,-10, 30,10);
      grd.addColorStop(0,'#79d3ff'); grd.addColorStop(1,'#3aa7e6');
      ctx.fillStyle = grd;
      roundRect(-30, -10, 60, 20, 10, true, false);
      // tail
      ctx.beginPath();
      ctx.moveTo(-36,0); ctx.lineTo(-52,-8); ctx.lineTo(-48,0); ctx.lineTo(-52,8); ctx.closePath();
      ctx.fillStyle = '#5cc2f5'; ctx.fill();
      // dorsal fin
      ctx.beginPath();
      ctx.moveTo(6,-10); ctx.quadraticCurveTo(2,-22, -4,-10); ctx.closePath();
      ctx.fillStyle = '#55b6ee'; ctx.fill();
      // eye
      ctx.beginPath(); ctx.arc(18,-3,2.2,0,Math.PI*2); ctx.fillStyle = '#0b2540'; ctx.fill();
      // spark
      ctx.globalAlpha = 0.25; ctx.fillStyle = '#9be1ff'; roundRect(8,-7,18,6,3,true,false); ctx.globalAlpha = 1;
      ctx.restore();

      // motion trail
      ctx.fillStyle = 'rgba(108,204,255,0.25)';
      ctx.fillRect(x-8, y+8, Math.max(6, Math.abs(vx*0.05)), 4);
    }

    function drawWave(o){
      ctx.save();
      ctx.translate(o.x, o.y);
      ctx.fillStyle = '#4cc3ff';
      ctx.strokeStyle = '#b7e6ff';
      // base rounded rect (collision body visual)
      roundRect(0, 4, o.w, 16, 8, true, false);

      // sine crest
      ctx.beginPath();
      const amp = 6, k = (Math.PI*2)/o.w, off = (o.phase*12)% (Math.PI*2);
      ctx.moveTo(0,6 + Math.sin(off)*amp);
      for(let x=0;x<=o.w;x+=4){
        const y = 6 + Math.sin(off + x*k)*amp;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(o.w, 4);
      ctx.lineTo(0, 4);
      ctx.closePath();
      ctx.fillStyle = '#73d4ff';
      ctx.fill();
      ctx.restore();
    }

    function roundRect(x, y, w, h, r, fill, stroke){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y, x+w,y+h, rr);
      ctx.arcTo(x+w,y+h, x,y+h, rr);
      ctx.arcTo(x,y+h, x,y, rr);
      ctx.arcTo(x,y, x+w,y, rr);
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    function drawBackground(){
      // grid
      ctx.save();
      ctx.globalAlpha = 0.07;
      ctx.strokeStyle = '#9ad0ff';
      ctx.lineWidth = 1;
      for(let x=0; x<canvas.width; x+=40){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
      }
      for(let y=0; y<canvas.height; y+=40){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
      }
      ctx.restore();
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawBackground();
      // player
      const p = state.player;
      drawDolphin(p.x, p.y, p.vx);
      // obstacles
      for(const o of state.obstacles){ drawWave(o); }

      if(!state.running){
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#e9ecf1';
        ctx.font = '700 42px system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign = 'center';
        ctx.fillText('Dolphin Dodger', canvas.width/2, canvas.height/2-20);
        ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto';
        ctx.fillStyle = '#aab1c6';
        ctx.fillText('イルカを操作して波を避けよう', canvas.width/2, canvas.height/2+16);
        ctx.fillText('スペースで開始・←/→ または A/D ・Pで一時停止（モバイルは下のボタン）', canvas.width/2, canvas.height/2+40);
      }

      if(state.paused){
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 28px system-ui, -apple-system';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
      }
    }

    function loop(t){
      if(!state.running || state.paused) return;
      if(!state.last) state.last = t;
      const dt = Math.min(0.033, (t - state.last)/1000);
      state.last = t;
      update(dt); draw();
      requestAnimationFrame(loop);
    }

    function gameOver(){ state.running = false; state.paused = false; toast.textContent = 'ゲームオーバー! R かボタンで再スタート'; draw(); saveBest(Math.floor(state.score)); }
    function startIfNotRunning(){ if(!state.running){ start(); } }

    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space'){ start(); e.preventDefault(); }
      if(e.key === 'p' || e.key === 'P'){ pauseToggle(); }
      if(e.key === 'r' || e.key === 'R'){ reset(); start(); }
      if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){ state.inputs.left = true; startIfNotRunning(); }
      if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){ state.inputs.right = true; startIfNotRunning(); }
    });
    window.addEventListener('keyup', (e)=>{
      if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') state.inputs.left = false;
      if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') state.inputs.right = false;
    });

    leftBtn.addEventListener('touchstart', ()=> { state.inputs.left = true; startIfNotRunning(); });
    leftBtn.addEventListener('touchend', ()=> state.inputs.left = false);
    rightBtn.addEventListener('touchstart', ()=> { state.inputs.right = true; startIfNotRunning(); });
    rightBtn.addEventListener('touchend', ()=> state.inputs.right = false);

    restartBtn.addEventListener('click', ()=>{ reset(); start(); });

    function saveBest(s){ try{ const key='dodger_best_v1'; const best=Number(localStorage.getItem(key)||0); if(s>best){ localStorage.setItem(key,String(s)); showBest(); } }catch(e){} }
    function showBest(){ try{ const key='dodger_best_v1'; const best=Number(localStorage.getItem(key)||0); if(best>0){ toast.textContent = `自己ベスト: ${best}`; setTimeout(()=>toast.textContent='', 2500);} }catch(e){} }

    function init(){ reset(); showBest(); draw(); }
    init();
  })();
  </script>
</body>
</html>
